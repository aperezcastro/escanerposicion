<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mapa de mi casa - Versión 1.1</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Datos en tiempo real - Versión 1.1</h3>
    <p>Pasos: <span id="steps">0</span></p>
    <p>Distancia: <span id="distance">0</span> metros</p>
</div>
<canvas id="canvas"></canvas>
<script>
    // Obtener el canvas y ajustar su tamaño
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    // Variables de posición y escala
    let positions = [{ x: 0, y: 0 }];
    let x = 0, y = 0; // Posición en metros
    let scale = 1; // Escala para ajustar al canvas
    let offsetX = width / 2;
    let offsetY = height / 2;

    // Variables para el pedómetro
    let steps = 0;
    let distance = 0;
    let stepLength = 0.7; // Longitud promedio del paso en metros (ajusta según tu altura)
    
    // Variables para detección de pasos
    let accMagnitudes = [];
    let accWindowSize = 50; // Tamaño de la ventana para el cálculo del umbral
    let threshold = null; // Umbral dinámico
    let lastStepTime = 0;
    let stepDelay = 400; // Tiempo mínimo entre pasos en ms

    // Variables para orientación
    let heading = 0; // Rumbo en radianes

    // Elementos para mostrar los datos
    let stepsElem = document.getElementById('steps');
    let distanceElem = document.getElementById('distance');

    // Solicitar permiso para acceder a los sensores (iOS 13+)
    function requestPermissions() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('devicemotion', handleMotion);
                    } else {
                        alert('Permiso denegado para acceder al acelerómetro.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('devicemotion', handleMotion);
        }

        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    } else {
                        alert('Permiso denegado para acceder a la orientación.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
    }

    requestPermissions();

    function handleOrientation(event) {
        // Obtener el ángulo alpha (rumbo) en grados
        if (event.absolute || event.alpha !== null) {
            heading = event.alpha; // En grados
        }
    }

    function handleMotion(event) {
        // Aceleración total incluyendo gravedad
        let ax = event.accelerationIncludingGravity.x || 0;
        let ay = event.accelerationIncludingGravity.y || 0;
        let az = event.accelerationIncludingGravity.z || 0;

        // Calcular la magnitud de la aceleración
        let accMagnitude = Math.sqrt(ax * ax + ay * ay + az * az);

        // Añadir la magnitud al array y mantener el tamaño de la ventana
        accMagnitudes.push(accMagnitude);
        if (accMagnitudes.length > accWindowSize) {
            accMagnitudes.shift();
        }

        // Calcular el umbral dinámico basado en el ruido de fondo
        if (threshold === null && accMagnitudes.length === accWindowSize) {
            // Asumimos que el dispositivo está en reposo al inicio
            let mean = accMagnitudes.reduce((a, b) => a + b, 0) / accMagnitudes.length;
            let variance = accMagnitudes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / accMagnitudes.length;
            let stdDev = Math.sqrt(variance);
            threshold = mean + stdDev * 2; // Establecer el umbral por encima del ruido normal
            console.log('Umbral establecido en:', threshold.toFixed(2));
            alert('Calibración completada. Puedes empezar a caminar.');
        }

        if (threshold !== null) {
            // Detección de picos
            let currentTime = Date.now();
            if (accMagnitude > threshold && (currentTime - lastStepTime > stepDelay)) {
                steps++;
                lastStepTime = currentTime;
                distance = steps * stepLength;

                // Convertir el heading a radianes y ajustar
                let headingRad = heading * Math.PI / 180;

                // Actualizar la posición en función del heading
                x += stepLength * Math.sin(headingRad);
                y -= stepLength * Math.cos(headingRad); // Restar porque el eje Y en pantalla va hacia abajo

                positions.push({ x: x, y: y });

                // Actualizar los elementos HTML
                stepsElem.textContent = steps;
                distanceElem.textContent = distance.toFixed(2);

                // Ajustar escala y offset
                adjustScaleAndOffset();

                // Limpiar el canvas
                ctx.clearRect(0, 0, width, height);

                // Dibujar la trayectoria
                ctx.beginPath();
                for (let i = 0; i < positions.length; i++) {
                    let px = positions[i].x * scale + offsetX;
                    let py = positions[i].y * scale + offsetY;
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }

    function adjustScaleAndOffset() {
        // Calcular los límites de las posiciones
        let minX = Math.min(...positions.map(p => p.x));
        let maxX = Math.max(...positions.map(p => p.x));
        let minY = Math.min(...positions.map(p => p.y));
        let maxY = Math.max(...positions.map(p => p.y));

        let dataWidth = maxX - minX;
        let dataHeight = maxY - minY;

        // Agregar un margen
        let margin = 20;

        // Calcular la escala para ajustar al canvas
        scale = Math.min(
            (width - 2 * margin) / dataWidth || 1,
            (height - 2 * margin) / dataHeight || 1
        );

        // Evitar escalas demasiado grandes o pequeñas
        scale = Math.min(scale, 100);
        scale = Math.max(scale, 1);

        // Calcular el offset para centrar el dibujo
        offsetX = - (minX + maxX) / 2 * scale + width / 2;
        offsetY = - (minY + maxY) / 2 * scale + height / 2;
    }

</script>
</body>
</html>
