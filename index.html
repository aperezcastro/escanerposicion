<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mapa de mi casa - Versión 1.2</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Datos en tiempo real - Versión 1.2</h3>
    <p>Pasos: <span id="steps">0</span></p>
    <p>Distancia: <span id="distance">0</span> metros</p>
</div>
<canvas id="canvas"></canvas>
<script>
    // Obtener el canvas y ajustar su tamaño
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    // Variables de posición y escala
    let positions = [{ x: 0, y: 0 }];
    let x = 0, y = 0; // Posición en metros
    let scale = 1; // Escala para ajustar al canvas
    let offsetX = width / 2;
    let offsetY = height / 2;

    // Variables para el podómetro
    let steps = 0;
    let distance = 0;
    let stepLength = 0.7; // Longitud promedio del paso en metros (ajusta según tu altura)

    // Variables para detección de pasos
    let accelData = [];
    let accelWindowSize = 50;
    let lastStepTime = 0;
    let stepDelay = 400; // Tiempo mínimo entre pasos en ms

    // Variables para orientación
    let heading = 0; // Rumbo en radianes

    // Elementos para mostrar los datos
    let stepsElem = document.getElementById('steps');
    let distanceElem = document.getElementById('distance');

    // Solicitar permiso para acceder a los sensores (iOS 13+)
    function requestPermissions() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('devicemotion', handleMotion);
                    } else {
                        alert('Permiso denegado para acceder al acelerómetro.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('devicemotion', handleMotion);
        }

        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    } else {
                        alert('Permiso denegado para acceder a la orientación.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
    }

    requestPermissions();

    function handleOrientation(event) {
        // Obtener el ángulo alpha (rumbo) en grados
        if (event.absolute || event.alpha !== null) {
            heading = event.alpha; // En grados
        }
    }

    function handleMotion(event) {
        let currentTime = Date.now();

        // Aceleración en el eje Z (vertical)
        let az = event.accelerationIncludingGravity.z || 0;

        // Guardar datos de aceleración
        accelData.push({ time: currentTime, value: az });
        if (accelData.length > accelWindowSize) {
            accelData.shift();
        }

        // Aplicar filtro de paso banda para aislar la frecuencia de los pasos
        if (accelData.length >= accelWindowSize) {
            let filteredAccel = bandpassFilter(accelData.map(a => a.value), event.interval || 0.02);
            let peakIndex = detectStep(filteredAccel);

            if (peakIndex !== -1 && (currentTime - lastStepTime > stepDelay)) {
                steps++;
                lastStepTime = currentTime;
                distance = steps * stepLength;

                // Convertir el heading a radianes y ajustar
                let headingRad = heading * Math.PI / 180;

                // Actualizar la posición en función del heading
                x += stepLength * Math.sin(headingRad);
                y -= stepLength * Math.cos(headingRad); // Restar porque el eje Y en pantalla va hacia abajo

                positions.push({ x: x, y: y });

                // Actualizar los elementos HTML
                stepsElem.textContent = steps;
                distanceElem.textContent = distance.toFixed(2);

                // Ajustar escala y offset
                adjustScaleAndOffset();

                // Limpiar el canvas
                ctx.clearRect(0, 0, width, height);

                // Dibujar la trayectoria
                ctx.beginPath();
                for (let i = 0; i < positions.length; i++) {
                    let px = positions[i].x * scale + offsetX;
                    let py = positions[i].y * scale + offsetY;
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }

    function bandpassFilter(signal, dt) {
        // Parámetros del filtro
        let fLow = 1; // Frecuencia mínima en Hz
        let fHigh = 3; // Frecuencia máxima en Hz
        let RC_low = 1 / (2 * Math.PI * fLow);
        let RC_high = 1 / (2 * Math.PI * fHigh);
        let alpha_low = dt / (RC_low + dt);
        let alpha_high = RC_high / (RC_high + dt);

        let lowPassed = [];
        let highPassed = [];
        lowPassed[0] = signal[0];
        highPassed[0] = signal[0];

        for (let i = 1; i < signal.length; i++) {
            lowPassed[i] = lowPassed[i - 1] + alpha_low * (signal[i] - lowPassed[i - 1]);
            highPassed[i] = alpha_high * (highPassed[i - 1] + signal[i] - signal[i - 1]);
        }

        // La señal filtrada es la diferencia entre las dos
        let bandPassed = [];
        for (let i = 0; i < signal.length; i++) {
            bandPassed[i] = lowPassed[i] - highPassed[i];
        }

        return bandPassed;
    }

    function detectStep(filteredAccel) {
        // Detectar picos en la señal filtrada
        let peakThreshold = 1.0; // Ajusta este valor según sea necesario
        for (let i = 1; i < filteredAccel.length - 1; i++) {
            if (
                filteredAccel[i] > filteredAccel[i - 1] &&
                filteredAccel[i] > filteredAccel[i + 1] &&
                filteredAccel[i] > peakThreshold
            ) {
                return i;
            }
        }
        return -1;
    }

    function adjustScaleAndOffset() {
        // Calcular los límites de las posiciones
        let minX = Math.min(...positions.map(p => p.x));
        let maxX = Math.max(...positions.map(p => p.x));
        let minY = Math.min(...positions.map(p => p.y));
        let maxY = Math.max(...positions.map(p => p.y));

        let dataWidth = maxX - minX;
        let dataHeight = maxY - minY;

        // Agregar un margen
        let margin = 20;

        // Calcular la escala para ajustar al canvas
        scale = Math.min(
            (width - 2 * margin) / dataWidth || 1,
            (height - 2 * margin) / dataHeight || 1
        );

        // Evitar escalas demasiado grandes o pequeñas
        scale = Math.min(scale, 100);
        scale = Math.max(scale, 1);

        // Calcular el offset para centrar el dibujo
        offsetX = - (minX + maxX) / 2 * scale + width / 2;
        offsetY = - (minY + maxY) / 2 * scale + height / 2;
    }

</script>
</body>
</html>
