<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mapa de mi casa - Versión 1.6</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 2;
        }
        #downloadBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 2;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Datos en tiempo real - Versión 1.6</h3>
    <p>Pasos: <span id="steps">0</span></p>
    <p>Distancia: <span id="distance">0</span> metros</p>
    <p>Conexión: <span id="connection">Desconocida</span></p>
</div>
<button id="downloadBtn">Descargar ruta</button>
<canvas id="canvas"></canvas>
<script>
    // Variables de configuración
    const stepLength = 0.7; // Longitud promedio del paso en metros (ajusta según tu altura)
    const stepDelay = 300; // Tiempo mínimo entre pasos en ms
    const stopDuration = 2000; // Tiempo en ms para considerar una parada
    const thresholdMultiplier = 1.2; // Multiplicador para establecer el umbral

    // Obtener elementos del DOM
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stepsElem = document.getElementById('steps');
    const distanceElem = document.getElementById('distance');
    const connectionElem = document.getElementById('connection');
    const downloadBtn = document.getElementById('downloadBtn');

    // Variables de estado
    let width, height;
    let steps = 0;
    let distance = 0;
    let positions = [{ x: 0, y: 0 }];
    let x = 0, y = 0;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let heading = 0;
    let lastStepTime = 0;
    let lastMovementTime = Date.now();
    let stops = [];

    // Variables para detección de pasos
    let accelHistory = [];
    const accelHistorySize = 50;
    let gravity = 9.81; // Aceleración de la gravedad en m/s²

    // Ajustar tamaño del canvas
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        width = canvas.width;
        height = canvas.height;
        offsetX = width / 2;
        offsetY = height / 2;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Solicitar permisos y agregar event listeners
    function requestPermissions() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('devicemotion', handleMotion);
                    } else {
                        alert('Permiso denegado para acceder al acelerómetro.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('devicemotion', handleMotion);
        }

        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    } else {
                        alert('Permiso denegado para acceder a la orientación.');
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
    }

    requestPermissions();

    function handleOrientation(event) {
        // Obtener el ángulo alpha (rumbo) en grados
        if (event.absolute || event.alpha !== null) {
            heading = event.alpha; // En grados
        }
    }

    function handleMotion(event) {
        const currentTime = Date.now();

        // Obtener la aceleración total
        const ax = event.accelerationIncludingGravity.x || 0;
        const ay = event.accelerationIncludingGravity.y || 0;
        const az = event.accelerationIncludingGravity.z || 0;

        // Calcular la magnitud de la aceleración
        const accMagnitude = Math.sqrt(ax * ax + ay * ay + az * az);

        // Aplicar un filtro de paso alto para eliminar la gravedad
        const accFiltered = Math.abs(accMagnitude - gravity);

        // Agregar el valor filtrado al historial
        accelHistory.push(accFiltered);
        if (accelHistory.length > accelHistorySize) {
            accelHistory.shift();
        }

        // Calcular el umbral dinámico
        const mean = accelHistory.reduce((sum, value) => sum + value, 0) / accelHistory.length;
        const variance = accelHistory.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / accelHistory.length;
        const stdDev = Math.sqrt(variance);
        const threshold = mean + stdDev * thresholdMultiplier;

        // Detección de picos (pasos)
        if (accFiltered > threshold && (currentTime - lastStepTime > stepDelay)) {
            steps++;
            lastStepTime = currentTime;
            lastMovementTime = currentTime;
            distance = steps * stepLength;

            // Convertir el heading a radianes
            const headingRad = heading * Math.PI / 180;

            // Actualizar la posición
            x += stepLength * Math.sin(headingRad);
            y -= stepLength * Math.cos(headingRad); // Restar porque el eje Y en pantalla va hacia abajo

            positions.push({ x: x, y: y });

            // Actualizar la interfaz
            stepsElem.textContent = steps;
            distanceElem.textContent = distance.toFixed(2);

            // Ajustar escala y offset
            adjustScaleAndOffset();

            // Dibujar en el canvas
            drawCanvas();
        }

        // Detección de parada
        if (currentTime - lastMovementTime > stopDuration && !lastMovementTime.stopped) {
            lastMovementTime.stopped = true;
            checkInternetConnection(x, y);
        } else if (currentTime - lastMovementTime <= stopDuration) {
            lastMovementTime.stopped = false;
        }
    }

    function checkInternetConnection(posX, posY) {
        // Intentar realizar una solicitud a un recurso externo
        fetch('https://www.google.com/favicon.ico', { method: 'HEAD', mode: 'no-cors' })
            .then(() => {
                // Conexión exitosa
                connectionElem.textContent = 'Conectado';
                stops.push({ x: posX, y: posY, status: 'Conectado' });
                drawCanvas();
            })
            .catch(() => {
                // Sin conexión
                connectionElem.textContent = 'Sin conexión';
                stops.push({ x: posX, y: posY, status: 'Sin conexión' });
                drawCanvas();
            });
    }

    function adjustScaleAndOffset() {
        // Calcular los límites de las posiciones
        let allX = positions.map(p => p.x).concat(stops.map(s => s.x));
        let allY = positions.map(p => p.y).concat(stops.map(s => s.y));
        let minX = Math.min(...allX);
        let maxX = Math.max(...allX);
        let minY = Math.min(...allY);
        let maxY = Math.max(...allY);

        let dataWidth = maxX - minX;
        let dataHeight = maxY - minY;

        // Agregar un margen
        let margin = 40;

        // Calcular la escala para ajustar al canvas
        scale = Math.min(
            (width - 2 * margin) / dataWidth || 1,
            (height - 2 * margin) / dataHeight || 1
        );

        // Evitar escalas demasiado grandes o pequeñas
        scale = Math.min(scale, 100);
        scale = Math.max(scale, 1);

        // Calcular el offset para centrar el dibujo
        offsetX = - (minX + maxX) / 2 * scale + width / 2;
        offsetY = - (minY + maxY) / 2 * scale + height / 2;
    }

    function drawCanvas() {
        ctx.clearRect(0, 0, width, height);

        // Dibujar la trayectoria
        ctx.beginPath();
        for (let i = 0; i < positions.length; i++) {
            let px = positions[i].x * scale + offsetX;
            let py = positions[i].y * scale + offsetY;
            if (i === 0) {
                ctx.moveTo(px, py);
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Dibujar las paradas con el estado de conexión
        for (let stop of stops) {
            let px = stop.x * scale + offsetX;
            let py = stop.y * scale + offsetY;
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, 2 * Math.PI);
            ctx.fillStyle = stop.status === 'Conectado' ? 'green' : 'red';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();

            // Añadir texto con el estado de conexión
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.fillText(stop.status, px + 12, py + 4);
        }
    }

    // Función para descargar la ruta como imagen
    downloadBtn.addEventListener('click', () => {
        let link = document.createElement('a');
        link.download = 'ruta.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    });
</script>
</body>
</html>
