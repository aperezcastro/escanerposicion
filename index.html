<!DOCTYPE html>
<html>
<head>
    <title>Detección de pasos con cámara - Versión 2.0</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #video { display: none; }
        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #downloadBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 2;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
<div id="overlay">
    <h3>Detección de pasos con cámara - Versión 2.0</h3>
    <p>Pasos detectados: <span id="steps">0</span></p>
    <button id="downloadBtn">Descargar ruta</button>
</div>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stepsElem = document.getElementById('steps');
    const downloadBtn = document.getElementById('downloadBtn');

    let width, height;
    let previousFrame = null;
    let steps = 0;
    let positions = [{ x: 0, y: 0 }];
    let x = 0, y = 0;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let heading = 0;
    let lastStepTime = 0;
    let stepDelay = 500; // Tiempo mínimo entre pasos en ms

    // Acceder a la cámara
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
        .then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                init();
                requestAnimationFrame(processFrame);
            };
        })
        .catch(err => {
            console.error("Error al acceder a la cámara: ", err);
            alert("No se pudo acceder a la cámara.");
        });

    function init() {
        width = video.videoWidth;
        height = video.videoHeight;
        canvas.width = width;
        canvas.height = height;
        offsetX = width / 2;
        offsetY = height / 2;
    }

    function processFrame() {
        try {
            ctx.drawImage(video, 0, 0, width, height);
            let currentFrame = ctx.getImageData(0, 0, width, height);

            if (previousFrame) {
                let motionLevel = calculateMotion(previousFrame.data, currentFrame.data);

                // Umbral para detección de movimiento
                let motionThreshold = 10; // Ajusta este valor según sea necesario

                if (motionLevel > motionThreshold) {
                    let currentTime = Date.now();
                    if (currentTime - lastStepTime > stepDelay) {
                        steps++;
                        lastStepTime = currentTime;

                        // Actualizar posición (asumiendo movimiento en dirección fija)
                        let stepLength = 0.7; // Longitud promedio del paso en metros
                        heading = 0; // Puedes actualizar el heading si obtienes orientación

                        x += stepLength * Math.cos(heading);
                        y += stepLength * Math.sin(heading);
                        positions.push({ x: x, y: y });

                        stepsElem.textContent = steps;

                        adjustScaleAndOffset();
                        drawRoute();
                    }
                }
            }

            previousFrame = currentFrame;
        } catch (e) {
            console.error(e);
        }

        requestAnimationFrame(processFrame);
    }

    function calculateMotion(prevData, currData) {
        let motion = 0;
        for (let i = 0; i < prevData.length; i += 4) {
            let rDiff = Math.abs(currData[i] - prevData[i]);
            let gDiff = Math.abs(currData[i + 1] - prevData[i + 1]);
            let bDiff = Math.abs(currData[i + 2] - prevData[i + 2]);
            let avgDiff = (rDiff + gDiff + bDiff) / 3;

            if (avgDiff > 20) { // Umbral para considerar movimiento en un píxel
                motion++;
            }
        }
        // Retornar porcentaje de píxeles con movimiento
        return (motion / (prevData.length / 4)) * 100;
    }

    function adjustScaleAndOffset() {
        let allX = positions.map(p => p.x);
        let allY = positions.map(p => p.y);
        let minX = Math.min(...allX);
        let maxX = Math.max(...allX);
        let minY = Math.min(...allY);
        let maxY = Math.max(...allY);

        let dataWidth = maxX - minX;
        let dataHeight = maxY - minY;

        let margin = 40;

        scale = Math.min(
            (canvas.width - 2 * margin) / dataWidth || 1,
            (canvas.height - 2 * margin) / dataHeight || 1
        );

        scale = Math.min(scale, 100);
        scale = Math.max(scale, 1);

        offsetX = - (minX + maxX) / 2 * scale + canvas.width / 2;
        offsetY = - (minY + maxY) / 2 * scale + canvas.height / 2;
    }

    function drawRoute() {
        // Limpiar el canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibujar la ruta
        ctx.beginPath();
        for (let i = 0; i < positions.length; i++) {
            let px = positions[i].x * scale + offsetX;
            let py = positions[i].y * scale + offsetY;
            if (i === 0) {
                ctx.moveTo(px, py);
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Función para descargar la ruta como imagen
    downloadBtn.addEventListener('click', () => {
        let link = document.createElement('a');
        link.download = 'ruta.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    });
</script>
</body>
</html>
